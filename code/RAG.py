# from langchain.document_loaders import UnstructuredPDFLoader
# from langchain.text_splitter import RecursiveCharacterTextSplitter
#
#
# def load_and_index_documents(pdf_file_path):
#     # 加载文档
#     loader = UnstructuredPDFLoader(pdf_file_path)
#     text = loader.load()
#     print('text\n', text)
#
#     # 拆分文档
#     chunk_size = 128
#     chunk_overlap = 20
#     text_splitter = RecursiveCharacterTextSplitter(chunk_size=chunk_size, chunk_overlap=chunk_overlap)
#     docs = text_splitter.split_documents(text)
#     return docs
#
# pdf_file_path = "data/10.1002_adem.201700820.pdf"
# docs = load_and_index_documents(pdf_file_path)
# print(docs)


str = "Why are drug combinations essential for HIV?\n\na) Single drugs are not completely inhibitory\n\nb) Mutations negate the effect of one drug\n\nc) Combinations of antibiotics are effective versus TB\n\nd) The virus cannot mutate vs a combination"

print(str)

[{
    'content': 'In this experiment, seven software teams developed versions of the same small-size (2000-4000 source instruction) application software product. Four teams used the Specifying approach. Three teams used the Prototyping approach. The main results of the experiment were the following. 1) Prototyping yielded products with roughly equivalent performance, but with about 40 percent less code and 45 percent less effort. 2) The prototyped products rated somewhat lower on functionality and robustness, but higher on ease of use and ease of learning. 3) Specifying produced more coherent designs and software that was easier to integrate. The paper presents the experimental data supporting these and a number of additional conclusions.',
    'source': 'Prototyping versus specifying: a multiproject experiment'},
    {
        'content': 'Rapid prototyping has created much interest in recent years and is gradually finding a foothold in software engineering. There is still, however, some confusion and disagreement about its potentials and role in software development. This paper first takes a broad look at the approaches to prototyping and then describes a large software project which employed an evolutionary prototyping approach. It concludes that, in contrary to some previous suggestions, evolutionary prototyping in not limited to small scale software and can cope with large projects as well.',
        'source': 'Experience with evolutionary prototyping in a large software project'},
    {
        'content': "In my view, the most interesting aspect of thisexperiment with prototypes is its implications for software engineering:everyone talks about prototypes today, but is anyone really producingany? Or, amongst those who do produce prototypes, how many can resistthe temptation, once the prototype is complete, to treat it as thefinished product? The experiences described here present a clear cutcase: it would have been impossible to write the compiler immediately inits final form—the cost of perpetual modifications, in response torevisions to ADA, of a compiler written in a `traditional' languagewould have been intolerably high—designing a prototype seems tohave been the only way out.Finally, once a decision in favor of prototypes has been taken,either as a way of giving concrete expression to a set of specificationsor a way of `protecting' a particular design, a choice of language inwhich to write the prototype has to be made. The advantages of SETL areclearly demonstrated in this article, with particular stress laid on thefacilities it provides for using several semantic levels, and thereforerefining a prototype in successive stages until the final productemerges, or a program very close to the final product. Translation intoa language providing for a higher performance level, or at any rate intoa more common language, C in this case, is then a simple task. My guessis that a lot of TSI readers are going to want more information on SETLto enable them to use it in similar circumstances in the future.To sum up, this article is particularly interesting for threereasons: it provides a closer understanding of ADA, demonstrates thevalue of prototypes in software design, and makes a plea in favor ofSETL which does indeed appear wholly satisfactory as a language in whichto write such prototypes.—From the Commentary by E. Girard—Commentary recommended by E. A. Feustel, Sherborn, MA",
        'source': 'The ADA/ED system: a large-scale experiment in software prototyping using SETL'},
    {
        'content': 'A procedure for evaluating a software prototype is presented. The need to assess the prototype itself arises from the use of prototyping to demonstrate the feasibility of a design or development strategy. The assessment procedure can also be of use in deciding whether to evolve a prototype into a complete system. The procedure consists of identifying evaluation criteria, defining alternative design approaches, and ranking the alternatives according to the criteria.',
        'source': 'An approach for assessing software prototypes'},
    {
        'content': "We are applying prototyping method using APL to a commercial compiler's development Project.This paper will discuss the following matters based on our one year experience of the project:Merits of APL as a prototyping language.An environment of the prototype.A representation of tables and the intermediate language of compilers in an APL environment.A strategy of transforming the APL prototype into final product written in Pascal.Evaluation of this method.",
        'source': 'APL as a prototyping language: case study of a compiler development project'},
    {
        'content': 'We describe a software prototyping environment implemented on the Lilith computer. By isolating hardware dependencies, the environment supports the development and testing of concurrent and distributed algorithms on a host as well as on the target hardware. A library of generic devices, which includes clocks, disks and EtherNets, is provided to support experimentation. The paper describes how any programming language can be extended to provide such an environment by adding subroutine packages for concurrent programming, simulation, and window management.',
        'source': 'StarLite, a visual simulation package for software prototyping'},
    {
        'content': "The objective of this paper is to provide a comparison of the following four information processing system development methodologies: The Box Structure Methodology, Application Prototyping, JSD and SASD. Each approach provides a unique and different set of activities that can be followed, with emphasis on different aspects of the life cycle. For this reason, no one methodology is superior in all areas and aspects of the development life cycle. However, each one is superior in its own sense, depending on the type of system being developed. The Box Structure Methodology provides a rigorous coverage of the analysis and design phases in the development life cycle, with the use of design graphics, and a design graphics language. JSD and SASD also use graphical structures as well. However, SASD relies heavily on dataflow diagrams in the analysis and design phases, where as JSD incorporates functions, time requirements, actions, and data into its diagrams in the analysis phase, and then applies them in the implementation phase, without ever going through a design step. Finally, the Application Prototyping development methodology offers an approach that centers around the development of a prototype, which is heavily dependent upon user interaction with the user in the feasibility and analysis phases, but does not offer any design, implementation, or maintenance techniques. A methodology is only approiate for a developer, once he/she has considered these fact, and determined the system's target environment.",
        'source': 'A presentation and comparison of four information system development methodologies'},
    {
        'content': 'ARCHI is a microarchitecture description language designed to serve as the underlying language for a retargetable firmware development environment. ARCHI provides a hierarchical, procedural description at the register transfer level of the target microarchitecture. This description can then be utilized by a meta-environment to generate an instantiation of the firmware development environment for a specific target microarchitecture.ARCHI has been successfully used to generate debugging simulators for the vertical Perkin-Elmer 3220, and the horizontal VAX-11/780. It is shown that if a microarchitecture description language is powerful enough to retarget a debugging simulator then it can be used to retarget almost every tool in a firmware development meta-environment, and that ARCHI accordingly satisfies its design objectives.',
        'source': 'A microarchitecture description language for retargeting firmware tools'},
    {
        'content': 'Recent work on generating tools and techniques have significantly eased the design and construction of programming environments (PEs). Concurrently, advances in workstation hardware have enhanced both the potential capabilities and performance of PEs. We argue that, to capitalize on these two developments, various deficiencies in traditional languages and operating systems must be avoided. To this end, we have developed Pegasus, a system to serve as a software foundation for the construction and execution of PEs. It consists of a concurrent functional programming language, the run-time support for this language, and a core library of standard tools and utilities. We present a discussion of Pegasus, its current state, and directions for future development.',
        'source': 'A foundation for programming environments'},
    {
        'content': 'Our goal is to develop formal methods for abstracting a given set of programs into a program schemaand for instantiating a given schema to satisfy concrete specifications. Abstraction and instantiationare two important phases in software development which allow programmers to apply knowledgelearned in the solutions of past problems when faced with new situations. For example, from twoprograms using a linear (or binary) search technique, an abstract schema can be derived that embodiesthe shared idea and that can be instantiated to solve similar new problems. Along similar lines, thedevelopment and application of program transformations are considered.We suggest the formulation of analogies as a basic tool in program abstraction. An analogy is firstsought between the specifications of the given programs; this yields an abstract specification thatmay be instantiated to any of the given concrete specifications. The analogy is then used as a basisfor transforming the existing programs into an abstract schema that represents the embeddedtechnique, with the invariant assertions and correctness proofs of the given programs helping toverify and complete the analogy. A given concrete specification of a new problem may then becompared with the abstract specification of the schema to suggest an instantiation of the schemathat yields a correct program.',
        'source': 'Program abstraction and instantiation'},
    {
        'content': "The aim of this paper is to develop a top-down design automation tool for digital system design such as microprogrammed processors. The package contains a hardware description language to specify the design, a microcode development module to generate an efficient microprogam for the microprogrammed processor's control, and a functional simulator module to verify the validity of the design. The goal of this project is to develop an interactive computer-aided design environment for specification, design and verification of instruction set processors.",
        'source': 'Microcode development for microprogrammed processors'},
    {
        'content': 'There are several alternatives for transforming algebraic specifications into executable prototypes. In this note the Equation Interpreter (a rewrite rule interpreter) and the University of New Hampshire Prolog interpreter are viewed as target systems for executing prototypes. The efficiencies of these systems are compared with each other.',
        'source': 'The efficiency of the equation interpreter compared with the UNH Prolog interpreter'},
    {
        'content': 'This article is both theoretical and empirical. Theoretically, it describes three principles of system design which we believe must be followed to produce a useful and easy to use computer system. These principles are: early and continual focus on users; empirical measurement of usage; and iterative design whereby the system (simulated, prototype, and real) is modified, tested, modified again, tested again, and the cycle is repeated again and again. This approach is contrasted to other principled design approaches, for example, get it right the first time, reliance on design guidelines. Empirically, the article presents data which show that our design principles are not always intuitive to designers; identifies the arguments which designers often offer for not using these principles—and answers them; and provides an example in which our principles have been used successfully.',
        'source': 'Designing for usability: key principles and what designers think'},
    {
        'content': 'Microprogramming has traditionally been done in assembly language because of the perceived need for fast execution; compiler technology does not yet exist for discovering and performing many of the clever tricks of an experienced microprogrammer. Unfortunately, programming at the machine-instruction level is both tedious and error-prone. A possible compromise between these two approaches is that of an interactive compiler, where the programmer guides the crafting of critical data structures and sections of code, while the compiler ensures that the resulting code has the same semantics as the original program, generates code where speed is not critical, and performs bookkeeping tasks. We are in the process of implementing a prototype of such a system. This paper describes the system being developed and discusses some of the key design issues.',
        'source': 'The design of an interactive compiler for optimizing microprograms'},
    {
        'content': 'This paper presents a hierarchical firmware design method. It allows to structure the design of a microprogrammed (level of a) computer architecture into independently verifiable modules. To specify the behaviour of the system we use the axiomatic architecture description language AADL. We illustrate the design and specification style using an emulation example.',
        'source': 'Design and specification of microprogrammed computer architectures'},
    {
        'content': 'The ACM SIGOPS Workshop on Accommodating Heterogeneity was conducted in December 1985 in Eastbound, Wash., as a forum for an international group of fifty researchers to discuss the technical issues surrounding heterogeneous computing environments.',
        'source': 'Heterogeneous computing environments: report on the ACM SIGOPS workshop on accommodating heterogeneity'},
    {
        'content': "From its beginning, the technology of personal workstations has been driven by visions of a future in which people would work in intimate partnership with computer systems on significant intellectual tasks. These visions have been expressed in various forms: Memex (Bush, 1945), Man-Machine Symbiosis (Licklider, 1960), NLS (Engelbart, 1963), Dynabook (Kay, 1977), and others.The tight coupling between human and computer required by these visions necessitated advances in the ways humans and computers interact. These advances have slowly begun to accumulate into what might be called a user technology. This user technology includes hardware and software techniques for building effective user interfaces: bitmapped displays, menus, pointing devices, “modeless” command languages, animation, and interface metaphors. But it must include a technical understanding of the user himself and of the nature of human-computer interaction. This latter part, the scientific base of user technology, is necessary in order to understand why interaction techniques are (or are not) successful, to help us invent new techniques, and to pave the way for machines that aid humans in performing significant intellectual tasks.In this paper, we trace some of the history of our understanding of users and their interaction with workstation—the personal part of personal workstations. In keeping with the spirit of other papers at this conference, we have centered this review around our own experiences, perspectives, and work and have not attempted a complete history of the field. In concentrating on our own work, we do not wish to mimimize the importance of others' work; we simply want to tell our own story. Our focus is on what we have learned about users in our years of studying them and how we see our findings relating to the original visions of the personal workstation.",
        'source': 'User technology—from pointing to pondering'}, {
    'content': 'It is very time-consuming and expensive to create the graphical, highly-interactive styles of user interfaces that are increasingly common. User Interface Management Systems (UIMSs) attempt to make the creation of user interfaces easier, but most existing UIMSs cannot create the low-level interaction techniques (pop-up pull-down and fixed menus, on-screen "light buttons", scroll-bars, elaborate feedback mechanisms and animations, etc.) that are frequently used. This paper describes Peridot, a system that automatically creates the code for these user interfaces while the designer demonstrates to the system how the interface should look and work. Peridot uses rule-based inferencing so no programming by the designer is required, and Direct Manipulation techniques are used to create Direct Manipulation interfaces, which can make full use of a mouse and other input devices. This allows extremely rapid prototyping of user interfaces.',
    'source': 'Creating highly-interactive and graphical user interfaces by demonstration'}, {
    'content': 'The Experimental Portable Standard Lisp Compiler (EPIC) is a compiler testbed for experimentation with, and development of, Lisp compilation strategies. EPIC uses an architectural description of the target machine to increase portability, and performs extensive optimizations in the form of source-to-source transformations, register allocation, and peephole optimization. It introduces machine-specific instructions early to enable machine-specific optimizations in the initial passes. EPIC produces better code than the original Portable Standard Lisp compiler, has an improved portability model, and is easier to maintain.',
    'source': 'EPIC - a retargetable, highly optimizing Lisp compiler'}, {
    'content': "A designer's expertise rests on the knowledge and skills which develop with experience in a domain. As a result, when a designer is designing an object in an unfamiliar domain he will not have the same knowledge and skills available to him as when he is designing an object in a familiar domain. In this paper we look at the software designer's underlying constellation of knowledge and skills, and at the way in which this constellation is dependent upon experience in a domain. What skills drop out, what skills, or interactions of skills come forward as experience with the domain changes? To answer the above question, we studied expert designers in experimentally created design contexts with which they were differentially familiar. In this paper we describe the knowledge and skills we found were central to each of the above contexts and discuss the functional utility of each. In addition to discussing the knowledge and skills we observed in expert designers, we will also compare novice and expert behavior.",
    'source': 'The Role of Domain Expenence in Software Design'}]
